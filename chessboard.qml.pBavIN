import QtQuick 2.15

pragma ComponentBehavior: Bound

Rectangle {
    id: recRoot
    anchors.fill: parent
    color: "#3f538a"

    property int padding: 16

    property real evalRatio: {
        if (!chessPosition) return 0.5;
        return Math.min( Math.max(chessPosition.evalScore * ((0.95 - 0.05) / 8.0) + 0.5, 0.05), 0.95)
    }

    // dark background track
    Rectangle {
        id: evalBarBg
        anchors {
            top: parent.top
            bottom: parent.bottom
            left: parent.left
            margins: padding
        }
        width: 20
        color: "#000000"
        radius: width / 2
    }

    // white fill bar
    Rectangle {
        id: evalBarFill
        anchors {
            bottom: evalBarBg.bottom
        }
        width: evalBarBg.width - 4
        x: evalBarBg.x + 2
        color: "#ffffff"
        radius: width / 2

        height: {
            if (!chessPosition) return 0.5;
            return evalBarBg.height * Math.min(Math.max(chessPosition.evalScore * 0.1125 + 0.5, 0.05), 0.95);
        }

        Behavior on height {
            NumberAnimation { duration: 300 }
        }
    }

    // a full‑screen mouse area to catch “cancel” taps
    MouseArea {
        id: promoCatcher
        anchors.fill: parent
        visible: promotionPending
        onClicked: {
            promotionPending = false
        }
    }

    // your Boolean and pending‐move data:
    property bool promotionPending: false
    property int promo_sr; property int promo_sc
    property int promo_dr; property int promo_dc

    Connections {
        target: chessPosition   // your C++ ChessPosition object
        onRequestPromotion: function(sr, sc, dr, dc) {
            console.log(sr)
            promo_sr = sr
            promo_sc = sc
            promo_dr = dr
            promo_dc = dc
            promotionPending = true
        }
    }

    // the promotion menu itself:
    Row {
        id: promoMenu
        spacing: 4
        visible: promotionPending

        // position it so its center is over the destination square
        x: board.x + promo_dc * board.cellSize + board.cellSize/2 - width/2
        y: board.y + promo_dr * board.cellSize + board.cellSize/2 - height/2
        z: 1000

        // the four promotion pieces, in order:
        Repeater {
            model: ["Q","R","B","N"]
            delegate: Image {
                source: "img/piece/alpha/" + (chessPosition.m_sideToMove==="w" ? "w" : "b") + modelData + ".svg"
                width: board.cellSize * 0.8
                height: width
                MouseArea {
                    anchors.fill: parent
                    onClicked: {
                        chessPosition.promotionSelected(promo_sr, promo_sc, promo_dr, promo_dc, modelData)
                        promotionPending = false
                    }
                }
            }
        }

        // and a cancel‑X in the last slot:
        Text {
            text: "✕"
            font.pixelSize: board.cellSize * 0.8
            color: "red"
            MouseArea {
                anchors.fill: parent
                onClicked: promotionPending = false
            }
        }
    }

    Item {
        id: board
        width: {
            return Math.min(parent.width - (padding + evalBarBg.width + padding)*2, parent.height - (padding)*2)
        }
        height: width
        anchors.centerIn: parent

        property real cellSize: width / 8
        property int dragOrigin: -1
        property var boardData: chessPosition ? chessPosition.boardData : [["", "", "", "", "", "", "", ""],["", "", "", "", "", "", "", ""],["", "", "", "", "", "", "", ""],["", "", "", "", "", "", "", ""],["", "", "", "", "", "", "", ""],["", "", "", "", "", "", "", ""],["", "", "", "", "", "", "", ""],["", "", "", "", "", "", "", ""]]

        Repeater {
            id: squareContainer
            model: 64

            Rectangle {
                id: square
                width: board.cellSize
                height: board.cellSize

                required property int index
                property int row: Math.floor(index / 8)
                property int col: index % 8

                color: ((Math.floor(index / 8) + (index % 8)) % 2 === 0) ? "#EEE" : "#999999"
                x: col * board.cellSize
                y: row * board.cellSize

                Rectangle {  // highlight
                    anchors.fill: parent
                    color: {
                        if (!chessPosition) return "00000000";
                        return chessPosition.isPreview ? "blue" : "yellow"
                    }
                    opacity: 0.2

                    // decode the one property:
                    visible: {
                        if (!chessPosition) return false;
                        var lm = chessPosition.lastMove;
                        if (lm < 0) return false;
                        var fromIdx = lm >> 8;
                        var toIdx   = lm & 0xFF;
                        var thisIdx = row*8 + col;
                        return thisIdx === fromIdx || thisIdx === toIdx;
                    }
                    z: 5
                }
            }
        }

        Repeater {
            id: pieceContainer
            model: 64

            Rectangle {
                id: piece
                width: board.cellSize
                height: board.cellSize
                color: "transparent"

                required property int index
                property int row: Math.floor(index / 8)
                property int col: index % 8

                x: col * board.cellSize
                y: row * board.cellSize
                z: pieceTouch.pressed ? 100 : 1

                Image {
                    // Svg Rasterisation
                    sourceSize.width: parent.width
                    sourceSize.height: parent.height

                    width: parent.width * 0.95
                    height: parent.height * 0.95

                    source: board.boardData[piece.row][piece.col] !== "" ? "img/piece/alpha/" + board.boardData[piece.row][piece.col] + ".svg" : ""

                    fillMode: Image.PreserveAspectFit

                    anchors.centerIn: pieceTouch.pressed ? undefined : parent
                    x:  pieceTouch.pressed ? pieceTouch.mouseX - (width / 2) : 0
                    y:  pieceTouch.pressed ? pieceTouch.mouseY - (height / 2) : 0
                }

                MouseArea {
                    id: pieceTouch
                    anchors.fill: piece

                    property int hoverCol: Math.floor((piece.x + mouseX) / board.cellSize)
                    property int hoverRow: Math.floor((piece.y + mouseY) / board.cellSize)

                    cursorShape: board.dragOrigin >= 0 ? Qt.ClosedHandCursor : (board.boardData[row][col] !== ""  ? Qt.PointingHandCursor : Qt.ArrowCursor)

                    onPressed: {
                        board.dragOrigin = index;
                    }

                    onReleased: {
                        board.dragOrigin = -1;
                        if (chessPosition)
                            chessPosition.release(piece.row, piece.col, hoverRow, hoverCol);
                    }

                    onPositionChanged: {
                        // Update the hover position on every mouse move
                        hoverCol = Math.floor((piece.x + mouseX) / board.cellSize)
                        hoverRow = Math.floor((piece.y + mouseY) / board.cellSize)
                    }
                }
            }
        }

    }
}
