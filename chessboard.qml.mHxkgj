import QtQuick 2.15

pragma ComponentBehavior: Bound

Rectangle {
    id: recRoot
    anchors.fill: parent
    color: "#3f538a"

    property int padding: 16

    property real evalRatio: {
        if (!chessPosition) return 0.5;
        return Math.min( Math.max(chessPosition.evalScore * ((0.95 - 0.05) / 8.0) + 0.5, 0.05), 0.95)
    }

    // dark background track
    Rectangle {
        id: evalBarBg
        anchors {
            top: parent.top
            bottom: parent.bottom
            left: parent.left
            margins: padding
        }
        width: 20
        color: "#000000"
        radius: width / 2
    }

    // white fill bar
    Rectangle {
        id: evalBarFill
        anchors {
            bottom: evalBarBg.bottom
        }
        width: evalBarBg.width - 4
        x: evalBarBg.x + 2
        color: "#ffffff"
        radius: width / 2

        // height = evalRatio * total height of track
        height: {
            if (!chessPosition) return 0.5;
            var ratio = Math.min(Math.max(chessPosition.evalScore * 0.1125 + 0.5, 0.05), 0.95);
            return evalBarBg.height * ratio;
        }

        Behavior on height {
            NumberAnimation { duration: 300 }
        }
    }

    Item {
        id: board
        anchors {
            top: parent.top
            bottom: parent.bottom
        }
        width: Math.min(parent.width - evalBarBg.width - padding*2, parent.height - padding*2)
        height: width

        property real cellSize: width / 8
        property int dragOrigin: -1
        property var boardData: chessPosition ? chessPosition.boardData : [["", "", "", "", "", "", "", ""],["", "", "", "", "", "", "", ""],["", "", "", "", "", "", "", ""],["", "", "", "", "", "", "", ""],["", "", "", "", "", "", "", ""],["", "", "", "", "", "", "", ""],["", "", "", "", "", "", "", ""],["", "", "", "", "", "", "", ""]]

        Repeater {
            id: squareContainer
            model: 64

            Rectangle {
                id: square
                width: board.cellSize
                height: board.cellSize

                required property int index
                property int row: Math.floor(index / 8)
                property int col: index % 8

                color: ((Math.floor(index / 8) + (index % 8)) % 2 === 0) ? "#EEE" : "#999999"
                x: col * board.cellSize
                y: row * board.cellSize

                Rectangle {  // highlight
                    anchors.fill: parent
                    color: {
                        if (!chessPosition) return "00000000";
                        return chessPosition.isPreview ? "blue" : "yellow"
                    }
                    opacity: 0.2

                    // decode the one property:
                    visible: {
                        if (!chessPosition) return false;
                        var lm = chessPosition.lastMove;
                        if (lm < 0) return false;
                        var fromIdx = lm >> 8;
                        var toIdx   = lm & 0xFF;
                        var thisIdx = row*8 + col;
                        return thisIdx === fromIdx || thisIdx === toIdx;
                    }
                    z: 5
                }
            }
        }

        Repeater {
            id: pieceContainer
            model: 64

            Rectangle {
                id: piece
                width: board.cellSize
                height: board.cellSize
                color: "transparent"

                required property int index
                property int row: Math.floor(index / 8)
                property int col: index % 8

                x: col * board.cellSize
                y: row * board.cellSize
                z: pieceTouch.pressed ? 100 : 1

                Image {
                    // Svg Rasterisation
                    sourceSize.width: parent.width
                    sourceSize.height: parent.height

                    width: parent.width * 0.95
                    height: parent.height * 0.95

                    source: board.boardData[piece.row][piece.col] !== "" ? "img/piece/alpha/" + board.boardData[piece.row][piece.col] + ".svg" : ""

                    fillMode: Image.PreserveAspectFit

                    anchors.centerIn: pieceTouch.pressed ? undefined : parent
                    x:  pieceTouch.pressed ? pieceTouch.mouseX - (width / 2) : 0
                    y:  pieceTouch.pressed ? pieceTouch.mouseY - (height / 2) : 0
                }

                MouseArea {
                    id: pieceTouch
                    anchors.fill: piece

                    property int hoverCol: Math.floor((piece.x + mouseX) / board.cellSize)
                    property int hoverRow: Math.floor((piece.y + mouseY) / board.cellSize)

                    cursorShape: board.dragOrigin >= 0 ? Qt.ClosedHandCursor : (board.boardData[row][col] !== ""  ? Qt.PointingHandCursor : Qt.ArrowCursor)

                    onPressed: {
                        board.dragOrigin = index;
                    }

                    onReleased: {
                        board.dragOrigin = -1;
                        if (chessPosition)
                            chessPosition.release(piece.row, piece.col, hoverRow, hoverCol);
                    }

                    onPositionChanged: {
                        // Update the hover position on every mouse move
                        hoverCol = Math.floor((piece.x + mouseX) / board.cellSize)
                        hoverRow = Math.floor((piece.y + mouseY) / board.cellSize)
                    }
                }
            }
        }

    }
}
